**Goal:**
Generate **full backend for Lumora** with **role-based authentication**, verification logic, manufacturer & admin workflows, QR/manual verification, AI certificate check, hotspot logging, and local storage. Use **Fastify, TypeScript, Prisma, PostgreSQL**. Include all endpoints, models, middleware, validations, logging, and edge-case handling and so on.

---

## **1️⃣ Core Requirements**

* **ORM:** Prisma
* **Database:** PostgreSQL / MySQL
* **Authentication:** JWT + refresh tokens
* **Roles:** `USER`, `MANUFACTURER`, `ADMIN`
* **File storage:** Local storage (`/uploads`) for QR codes, certificates, images
* **Validation:** Zod schemas for all inputs
* **Logging:** All verifications logged with timestamp, location (if consent given), status
* **AI Integration:**

  * Certificate forgery detection (manufacturer registration)
  * Counterfeit hotspot detection (reused codes + geo clustering)
* **Extra Considerations:**

  * Users can scan products from manufacturers **not yet registered on Lumora** → marked as `NON_NETWORK` but not automatically “invalid”
  * Rate-limiting on verification endpoints to prevent abuse
  * Database indexes for `fullCode`, `batchId`, `manufacturerId` for performance

---

## **2️⃣ Authentication & Authorization**

### **Endpoints**

* `POST /auth/register` → create user or manufacturer (role assigned)
* `POST /auth/login` → authenticate & return JWT + refresh token
* `POST /auth/refresh` → refresh JWT token
* `GET /profile` → get user profile (role-based)
* `PUT /profile` → update profile info (name, password, avatar, settings, notifications, etc.)

### **Notes**

* Hash passwords securely (bcrypt)
* JWT payload includes `id` and `role`
* Role-based middleware for route protection
* Public routes limited (login/register)
* Authenticated routes: user dashboard, QR scanning, manual verify, history
* Manufacturer/admin routes protected

---

## **3️⃣ User Verification**

### **Endpoints**

* `POST /verify/manual` → input code → return status: `GENUINE | USED | INVALID | NON_NETWORK`
* `POST /verify/qr` → QR scan → same status as manual
* `GET /history` → user verification history

### **Logic**

* Check code in DB → product + batch
* Status logic:
  * maybe ENUINE` → mark scanned
  * ⚠️ `USED` → mark scanned + log location (with consent)
  * ❌ `INVALID` → reject
  * ⚪ `NON_NETWORK` → code not in system (manufacturer not registered) → log scan, user informed
* Store all scans in `VerificationLogs` table: `code, productId, batchId, userId, status, timestamp, location (optional), metadata (IP/device)`

---

## **4️⃣ Manufacturer Features**

### **Endpoints**

* `POST /manufacturer/products` → create product
* `GET /manufacturer/products` → list products
* `GET /manufacturer/products/:id` → product detail + batches
* `POST /manufacturer/batches` → create batch (quantity, production & expiry date)
* `GET /manufacturer/batches/:id` → batch detail + codes
* `POST /manufacturer/codes` → generate codes (manual + QR)
* `GET /manufacturer/analytics` → verification stats + suspicious scans + hotspot data

### **Logic**

* Only **verified manufacturers** can create products/batches/codes
* AI certificate check during manufacturer registration (local file upload)
* QR codes generated locally, saved in `/uploads/qr/`

---

## **5️⃣ Admin Features**

### **Endpoints**

* `GET /admin/manufacturers` → list all manufacturers, filter by status (`PENDING`, `VERIFIED`, `REJECTED`)
* `PUT /admin/manufacturers/:id/approve` → approve manufacturer
* `PUT /admin/manufacturers/:id/reject` → reject manufacturer
* `GET /admin/products` → view all products
* `GET /admin/verifications` → view all code verifications
* `GET /admin/hotspots` → counterfeit hotspot data (geo cluster)
* `GET /admin/analytics` → platform-wide metrics
(and other endpoint we need to add, that is inclusive in frontend)

### **Logic**

* Admin can **view but not modify** manufacturer products or batches
* Counterfeit hotspots computed via location of reused codes
* All logs stored in DB with timestamps

---

## **6️⃣ Database Schema (High-Level)**

**Tables:**

* `Users`: id, name, email, password, role, settings, createdAt, updatedAt
* `Manufacturers`: id, userId, companyName, nafdacNumber, certificatePath, verificationStatus, aiScore, createdAt, updatedAt
* `Products`: id, manufacturerId, name, category, description, createdAt, updatedAt
* `Batches`: id, productId, batchNumber, productionDate, expiryDate, quantity, createdAt, updatedAt
* `Codes`: id, batchId, fullCode, qrPath, status, scannedCount, createdAt, updatedAt
* `VerificationLogs`: id, codeId (nullable), productId, batchId, userId, status, inputCode, location (optional), metadata (optional), timestamp
* `Hotspots` (optional precomputed table for clusters)

**Notes:**

* Index `fullCode`, `batchId`, `manufacturerId`
* `Product.category` could be an enum (`DRUG`, `SKINCARE`, `CLOTHES`, `ELECTRONICS`)

---

## **7️⃣ Additional Features**

* File upload: certificates, QR codes → `/uploads`
* AI Certificate Verification → returns score & status
* Counterfeit Hotspot → backend computes clusters from `VerificationLogs` where status = `USED`
* Notifications → alerts for suspicious scans
* Role-based guards → Fastify middleware
* Error handling → Zod validation, JWT errors, DB errors
* Logging → all successful & failed attempts

---

## **8️⃣ Security & Middleware**

* JWT auth for all authenticated routes
* Role-based middleware (`USER`, `MANUFACTURER`, `ADMIN`)
* Rate limiting for `/verify/manual` & `/verify/qr`
* Validation middleware (Zod) for all inputs
* Consent check for location logging

---

## **9️⃣ Expected Output**

* Fully working backend
* Role-based route guards
* All endpoints for Users, Manufacturers, and Admin
* Prisma models + migrations
* Local file upload handling
* QR code generation & manual code verification
* AI integration hooks (certificate & hotspot detection)
* Logging & error handling
* Hackathon-worthy: user can scan products from non-registered manufacturers (`NON_NETWORK`) without marking them fake

Logging & error handling
 and a user should be able to scan other manufacturer product not registered with us like this drug might not be fake it might just be that the manufacturer isn't using our app (that dosen't mean there won't be , or you won't still log INVALID we having our normal 3 but including this i just highlighted, you should know how to), prolly thay have their own code (do you get?) so it will be hackhathon worthy, though we might have other features we've done in backend that's i did not list here so include everything we've done. and youre also free to add anyhting and give suggestion but lemme know.

 and let's start with tha package i am installing and folder structure.. So let's start. DO NOT FORGET, CODE AS A SENIOR BACKEND ENGINEER

 and  i am using trained ai model hugging face and gemini:
maybe we should Use Hugging Face (or custom model) for:
- Initial classification: Check if an image/document is likely manipulated or not (e.g., image forgery detection).
- Return: Real, Likely Manipulated, Unclear.
maybe  Use Gemini for:
- Contextual analysis:
  - Is the text blurred, inconsistent?
  - Does it look pasted or digitally altered?
  - Compare structure with expected layout (e.g., NAFDAC certificate design).
- Return: Natural language explanation (e.g., "Stamp appears fake", "Mismatch in font sizes", etc).